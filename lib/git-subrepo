#!/usr/bin/env bash
#
# Copyright 2013, 2014 - Ingy döt Net <ingy@ingy.net>
#

# Exit on any errors:
set -e

# Import Bash+ helper functions:
BASHLIB="${BASH_SOURCE%/*}/git-subrepo.d"
PATH="$BASHLIB:$PATH" source bash+.bash
bash+:import :std can

VERSION=0.0.1

# `git rev-parse` turns this into a getopt parser and a command usage:
GETOPT_SPEC="\
git subrepo <command> <options> <arguments>

Commands:
  clone, push, pull, status, help

See 'git help subrepo' for complete documentation and usage of each command.

Options:
--
h           Show the command summary
help        Show the complete documentation

b,branch=   Which branch/commit/refspec (default to master)

q,quiet     Show minimal output
v,verbose   Show verbose output
X,debug     Turn on -x Bash debugging
"

#------------------------------------------------------------------------------
# Top level function:
#------------------------------------------------------------------------------
main() {
  # Define globals:
  local command=
  local command_arguments=()
  local quiet_output=false
  local verbose_output=false

  local subdir              # Subdirectory of the subrepo being used
  local gitrepo             # Path to .gitrepo file

  local head_commit         # HEAD commit id at start of command
  local tree_commit
  local update_commit
  local merge_commit

  local subrepo_remote
  local subrepo_branch
  local subrepo_commit
  local subrepo_commit_old
  local subrepo_former

  # Check environment and parse CLI options:
  assert-ok
  get-opts "$@"

  # Make sure command exists:
  can "command:$command" ||
    error "unknown 'git subrepo' command: '$command'\n"

  # Make sure repo is in the proper state:
  [ $command == help ] || assert-ready

  # Run the command:
  "command:$command" "${command_arguments[@]}"
}

#------------------------------------------------------------------------------
# API command functions:
#------------------------------------------------------------------------------

# Launch the manpage viewer:
command:help() {
  exec git help subrepo
}

# `git subrepo clone …` command:
command:clone() {
  subrepo_remote="${1:?"subrepo remote url required"}"
  subrepo_branch=${subrepo_branch:-master}

  # Set subdir and gitrepo values:
  set-subdir-or-guess "$2"
  gitrepo="$subdir/.gitrepo"

  # Subdir must not already exist, for clone operation:
  assert-empty $subdir

  # Get the current HEAD commit:
  head_commit=$(git rev-parse HEAD)

  # Fetch all the git objects from the subrepo/branch:
  git fetch --quiet "$subrepo_remote" "$subrepo_branch" 2> /dev/null ||
    error "command failed: git fetch $subrepo_remote $subrepo_branch"

  # Get the subrepo HEAD commit:
  subrepo_commit="$(git rev-parse FETCH_HEAD)"

  # Read the subrepo into the index (under subdir):
  git read-tree --prefix="$subdir" $subrepo_commit

  # Checkout the subrepo as a new subdir:
  git checkout -- "$subdir"

  # Make a tree object from the index:
  tree_commit=$(git write-tree)

  # Create a commit object from the tree:
  update_commit="$(
    action-message cloned |
    git commit-tree \
      "$(git log --max-count=1 --format=%T $subrepo_commit)"
  )"

  # Create a merge commit:
  merge_commit="$(
    echo "Merge commit '$(git rev-parse --short "$update_commit")'" |
    git commit-tree $tree_commit \
      -p $head_commit \
      -p $update_commit
  )"

  # Set HEAD ref:
  git reset "$merge_commit"

  # Add/amend the subdir/.gitrepo file:
  update-gitrepo "$update_commit" "clone"

  # Successful command output:
  say "git subrepo '$subrepo_remote' cloned into '$subdir'"
}

# `git subrepo pull …` command:
command:pull() {
  # Read current subrepo state:
  set-subdir "${1:?"subdir is required"}"
  read-gitrepo

  # Fetch the current subrepo objects:
  git fetch --quiet "$subrepo_remote" "$subrepo_branch" 2> /dev/null ||
    die "failure: git fetch $subrepo_remote $subrepo_branch"

  # Get the current subrepo HEAD commit:
  subrepo_commit=$(git rev-parse FETCH_HEAD)

  # Check if we already are up to date:
  if [ "$subrepo_commit" == "$subrepo_commit_old" ]; then
    say "subrepo '$subdir' is up to date"
    return
  fi

  # Create the update commit:
  update_commit="$(
    action-message pulled |
    git commit-tree \
      "$(git log --max-count=1 --format=%T "$subrepo_commit")" \
      -p "$subrepo_former"
  )"

  # Merge the update with the subtree strategy:
  git merge -s recursive -X subtree="$subdir" "$update_commit" > /dev/null

  # Add/amend the subdir/.gitrepo file:
  update-gitrepo "$update_commit"

  # Successful command output:
  say "git subrepo '$subdir' pulled from '$subrepo_remote' ($subrepo_branch)"
}

# `git subrepo push …` command:
command:push() {
  # Read current subrepo state:
  set-subdir "${1:?"subdir is required"}"
  read-gitrepo

  # XXX See if any changes to subdir since last push
    # Say "no changes to push"

  # Save current head to get back to it later
  head_commit=$(git rev-parse HEAD)

  # Fetch the current subrepo objects:
  git fetch --quiet "$subrepo_remote" "$subrepo_branch" \
    2> /dev/null \
    || die "failure: git fetch $subrepo_remote $subrepo_branch"

  # Make hist of changes since last sync
  git filter-branch -f \
    --subdirectory-filter "$subdir" \
    --parent-filter "sed 's/-p $subrepo_former//'" \
    -- $subrepo_former..HEAD \
    &> /dev/null

  git filter-branch -f \
    --tree-filter "rm -f .gitrepo" \
    &> /dev/null

  root=$(git rev-list --max-parents=0 HEAD)
  echo "$root $subrepo_commit" >> .git/info/grafts

  git rebase FETCH_HEAD \
    &> /dev/null

  # subrepo_new=$(git rev-parse HEAD)

  # push to remote
  git push $subrepo_remote $subrepo_branch \
    &> /dev/null

  # reset to starting commit
  git reset --hard $head_commit \
    &> /dev/null

  # Does $subdir/.gitrepo need updating?

  # say OK
  say "git subrepo '$subdir' pushed to '$subrepo_remote' ($subrepo_branch)"
}

# `git subrepo status …` command:
# Should list all subrepos if no args
# Should tell info about a subdir if argument given
command:status() {
  local subdir gitrepo
}

command:split() {
  local subdir gitrepo
}


#------------------------------------------------------------------------------
# Support functions:
#------------------------------------------------------------------------------

# Parse command line options:
get-opts() {
  [ $# -eq 0 ] && set -- --help

  [ -n "$GIT_SUBREPO_DEBUG" ] && set -x
  [ -n "$GIT_SUBREPO_QUIET" ] && quiet_output=true
  [ -n "$GIT_SUBREPO_VERBOSE" ] && verbose_output=true

  eval "$(
    echo "$GETOPT_SPEC" |
      git rev-parse --parseopt -- "$@" ||
    echo exit $?
  )"

  while [ $# -gt 0 ]; do
    local option="$1"; shift
    case "$option" in
      -q) quiet_output=true ;;
      -v) verbose_output=true ;;
      -X) set -x ;;
      -b) subrepo_branch="$1"; shift ;;
      --) break ;;
      *) error "unexpected option: $option" ;;
    esac
  done

  command="$1"; shift
  command_arguments=("$@")
}

set-subdir() {
  local dir="$1"
  [[ "$dir" =~ ^/ ]] &&
    error "subdir '$dir' should not be absolute path"
  subdir="${dir%%/}"
}

# Determine the correct subdir path to use:
set-subdir-or-guess() {
  local dir="$1"
  if [ -z "$dir" ]; then
    dir="${subrepo_remote%/}"
    dir="${dir##*/}"
    dir="${dir%.git}"
    [[ "$dir" =~ [a-zA-Z] ]] ||
      error "can't determine subdir from '$subrepo_remote'"
  fi
  set-subdir "$dir"
}

# Set subdir and gitrepo vars:
read-gitrepo() {
  gitrepo="$subdir/.gitrepo"

  if [ ! -f "$gitrepo" ]; then
    error "'$subdir' is not a subrepo"
  fi

  # Read .gitrepo values:
  subrepo_remote="$(git config --file="$gitrepo" subrepo.remote)"
  [ -z "$subrepo_branch" ] &&
    subrepo_branch="$(git config --file="$gitrepo" subrepo.branch)"
  subrepo_commit_old="$(git config --file="$gitrepo" subrepo.commit)"
  subrepo_former="$(git config --file="$gitrepo" subrepo.former)"
}

# Check that system is ok for this command:
assert-ok() {
  type git &> /dev/null ||
    error "can't find your 'git' command in '$PATH'"
  local version="$(git --version)"
  if [[ "$version" < "git version 1.7" ]]; then
    error "requires git version 1.7 or higher; you have '$version'"
  fi
}

# Make sure git repo is ready:
assert-ready() {
  # In a work-tree:
  [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" == true ] ||
    error "can't 'subrepo $command' outside a working tree."

  # HEAD exists:
  git rev-parse --verify HEAD >/dev/null || die

  # Repo is in a clean state:
  git update-index -q --ignore-submodules --refresh
  git diff-files --quiet --ignore-submodules ||
    error "can't $action subrepo. Unstaged changes."
  git diff-index --quiet --ignore-submodules HEAD ||
    error "can't $action subrepo. Working tree has changes."
  git diff-index --quiet --cached --ignore-submodules HEAD ||
    error "can't $action subrepo. Index has changes."

  # For now, only support actions from top of repo:
  [ "$(git rev-parse --git-dir)" == '.git' ] ||
    error "need to be at the top level directory of the repo."

  :
}

# If subdir exists, make sure it is empty:
assert-empty() {
  subdir="$1"
  if [ -e "$subdir" ] && [ -n "$(ls -A $subdir)" ]; then
    error "subdir '$subdir' exists and is not empty"
  fi
}

# Commit msg for an action commit:
action-message() {
  action="$1"
  cat <<...
subrepo $action into '$subdir/'

subrepo remote: $subrepo_remote
subrepo branch: $subrepo_branch
subrepo commit: $subrepo_commit
...
}

# Update the subdir/.gitrepo state file:
update-gitrepo() {
  local change_commit="$1"
  local subrepo_former="$change_commit"
  local short_commit=$(git rev-parse --short "$change_commit")

  if [ "$2" == "clone" ]; then
    cat <<... > $gitrepo
; DO NOT EDIT (unless you know what you are doing)
;
; This subdirectory is a git subrepo, and this file is maintained by the
; git-subrepo command. See https://github.com/ingydotnet/git-subrepo#readme
;
...
  fi

  git config --file="$gitrepo" subrepo.remote "$subrepo_remote"
  git config --file="$gitrepo" subrepo.branch "$subrepo_branch"
  git config --file="$gitrepo" subrepo.commit "$subrepo_commit"
  git config --file="$gitrepo" subrepo.former "$change_commit"
  git add "$gitrepo"
  git commit \
    --quiet \
    --amend \
    --message="Merge subrepo commit '$short_commit'"
}

# Smart output:
say() {
  $quiet_output && return
  echo "$@"
}

# Nicely report common error messages:
error() {
  local msg=
  printf -v msg "Error: %s\n" "$1"
  die "$msg"
}

[ "$BASH_SOURCE" == "$0" ] && main "$@"

true
