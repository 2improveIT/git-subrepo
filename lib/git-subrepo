#!/usr/bin/env bash
#
# Copyright 2013, 2014 - Ingy döt Net <ingy@ingy.net>
#

# Exit on any errors:
set -e

# Import Bash+ helper functions:
BASHLIB="${BASH_SOURCE%/*}/git-subrepo.d"
PATH="$BASHLIB:$PATH" source bash+.bash
bash+:import :std can

VERSION=0.1.0

# `git rev-parse` turns this into a getopt parser and a command usage:
GETOPT_SPEC="\
git subrepo <command> <arguments> <options>

Commands:
  clone     Clone a remote repository into a local directory (subrepo)
  push      Push local subrepo changes upstream
  pull      Pull (merge) upstream changes to the subrepo
  checkout  Create/checkout a local branch containing just the subrepo
  status    Get status of a subrepo (or all of them)

  help      Read the (full) git-subrepo documentation
  version   Display git-subrepo version info

See 'git help subrepo' for complete documentation and usage of each command.

Options:
--
h           Show the command summary
help        Show the complete documentation
version     Print the git-subrepo version number

b,branch=   Upstream branch/commit/refspec (default to master)

q,quiet     Show minimal output
v,verbose   Show verbose output
x,debug     Turn on -x Bash debugging
"

#------------------------------------------------------------------------------
# Top level function:
#------------------------------------------------------------------------------
main() {
  # Define global variables:
  local command=              # Subrepo subcommand to run
  local command_arguments=()  # Command args after getopt parsing
  local quiet_output=false    # Output should be quiet
  local verbose_output=false  # Output should be verbose
  local OK=0                  # Flag that commands have succeeded

  local subdir                # Subdirectory of the subrepo being used
  local gitrepo               # Path to .gitrepo file
  local checkout_branch       # Branch name to checkout to (push from)

  local original_head_commit  # HEAD commit id at start of command
  local original_branch       # HEAD ref at start of command
  local upstream_head         # HEAD commit id from a subrepo fetch
  local update_commit         # Commit made for clone or pull

  local subrepo_remote        # Remote url for subrepo's upstream repo
  local subrepo_branch        # Upstream branch to clone/push/pull
  local subrepo_commit_old    # Upstream HEAD from previous clone/pull
  local subrepo_former        # Local commit from previous clone/pull

  # Check environment and parse CLI options:
  assert-environment-ok
  get-command-options "$@"

  # Make sure command exists:
  can "command:$command" ||
    error "unknown 'git subrepo' command: '$command'"

  # Make sure repo is in the proper state:
  [ "$command == help" -o "$command" == status ] \
    || assert-repo-is-ready

  # Run the command:
  "command:$command" "${command_arguments[@]}"
}

#------------------------------------------------------------------------------
# API command functions:
#------------------------------------------------------------------------------

# Launch the manpage viewer:
command:help() {
  exec git help subrepo
}

# `git subrepo clone …` command:
command:clone() {
  subrepo_remote="${1:?"subrepo remote url required"}"
  subdir="${2:-"`guess-subdir $subrepo_remote`"}"
  subrepo_branch=${subrepo_branch:-master}

  command-setup

  # Read the subrepo into the index (under subdir):
  git read-tree --prefix="$subdir" $upstream_head

  # Checkout the subrepo as a new subdir:
  git checkout -- "$subdir"

  # Create a tree object from the index:
  local tree_commit=$(git write-tree)

  # Create a commit object from the tree:
  update_commit="$(
    action-message |
    git commit-tree \
      "$(git log --max-count=1 --format=%T $upstream_head)"
  )"

  # Create a merge commit:
  local merge_commit="$(
    echo "..." |
    git commit-tree $tree_commit \
      -p $original_head_commit \
      -p $update_commit
  )"

  # Set HEAD ref:
  git reset --hard "$merge_commit" \
    &> /dev/null

  # Add the subdir/.gitrepo file:
  update-gitrepo-file

  # Successful command output:
  say "git subrepo '$subdir' cloned from '$subrepo_remote' ($subrepo_branch)"

  update-remotes-branches
}

# `git subrepo pull …` command:
command:pull() {
  subdir="${1:?"subdir is required"}"

  command-setup

  # Check if we already are up to date:
  if [ "$upstream_head" == "$subrepo_commit_old" ]; then
    say "subrepo '$subdir' is up to date"
    return
  fi

  # Create the update commit:
  update_commit="$(
    action-message |
    git commit-tree \
      "$(git log --max-count=1 --format=%T "$upstream_head")" \
      -p "$subrepo_former"
  )"

  # Merge the update with the subtree strategy:
  git merge -s recursive -X subtree="$subdir" "$update_commit" > /dev/null

  # Prune the merge history to keep things looking clean:
  git filter-branch -f \
    --parent-filter "sed 's/ -p $subrepo_former//'" \
    -- $update_commit^..HEAD ^HEAD^ \
    &> /dev/null

  # The update_commit just got rewritten. Need new id:
  update_commit=$(git rev-parse HEAD^2)

  # Update the subdir/.gitrepo file:
  update-gitrepo-file

  # Successful command output:
  say "git subrepo '$subdir' pulled from '$subrepo_remote' ($subrepo_branch)"

  update-remotes-branches
}

# `git subrepo push …` command:
command:push() {
  subdir="${1:?"subdir is required"}"
  command-setup

  # Checkout the subrepo to a branch:
  subrepo-checkout

  # Attempt to rebase changes onto upstream:
  git rebase $upstream_head $checkout_branch \
    &> /dev/null \
    || OK=1

  if OK; then
    git push "$subrepo_remote" "+$checkout_branch:$subrepo_branch" \
      &> /dev/null \
      || OK=1
  fi

  if OK; then
    say "git subrepo '$subdir' pushed to '$subrepo_remote' ($subrepo_branch)"
  else
    say "The subrepo push command failed to rebase to upstream."
    say "Try 'git subrepo checkout', and then merge by hand."
    say "See doc for more info: 'git subrepo help'."
  fi

  # Checkout starting branch:
  git checkout $original_branch \
    &> /dev/null
  # Delete the checkout branch:
  git branch -D $checkout_branch \
    &> /dev/null

  update-remotes-branches
}

# `git subrepo checkout …` command:
command:checkout() {
  subdir="${1:?"subdir is required"}"
  command-setup

  # Checkout the subrepo to a branch:
  subrepo-checkout

  say "Subrepo '$subdir' checked out to local branch '$checkout_branch'."
  say ""
  say "Your remote tracking branch '...' is up to date."
  say ""
  say "You can now merge/rebsae your local changes with the upstream."
  say ""
  say "When you have finishing merging, pull or push the subrepo with:"
  say ""
  say "  git subrepo pull $subdir"
  say "  git subrepo push $subdir"
  say ""
}

# `git subrepo status …` command:
# Should list all subrepos if no args
# Should tell info about a subdir if argument given
command:status() {
  local subrepos=()

  if [ $# -eq 0 ]; then
    get-all-subrepos
  else
    all_subrepos=$*
  fi

  local s
  for s in ${all_subrepos[@]}; do
    subrepo-status "$s"
  done
}

# Checkout the subrepo changes since last push:
subrepo-checkout() {
  # Delete old checkout branch if exists:
  git branch -d "$checkout_branch" \
    &> /dev/null \
    || true

  # Make history of subdir changes:
  git filter-branch -f \
    --subdirectory-filter "$subdir" \
    -- HEAD \
    &> /dev/null

  # Remove the .gitrepo file from the history:
  git filter-branch -f \
    --tree-filter "rm -f .gitrepo" \
    &> /dev/null

  # Graft the history to the upstream (for rebase's sake):
  root=$(git rev-list --max-parents=0 HEAD)
  echo "$root $subrepo_commit_old" >> .git/info/grafts

  # Create a branch for this checkout:
  git checkout -f -b $checkout_branch \
    &> /dev/null

  # Reset to original state:
  echo "$original_head_commit" > ".git/refs/heads/$original_branch"
  git checkout $original_branch \
    &> /dev/null
}

subrepo-status() {
  local subdir="${1#./}"
  local subdir_path="$subdir"
  subdir="${subdir%/}"
  read-gitrepo-file

  [ ! -f "$subdir/.gitrepo" ] &&
    error "'$subdir' is not a subrepo"
  cat <<...
Git subrepo '$subdir':
  remote name:     subrepo/$subdir
  remote url:      $subrepo_remote
  remote branch:   subrepo/remote/$subdir
  tracking branch: $subrepo_branch

...

  update-remotes-branches
}

#------------------------------------------------------------------------------
# Support functions:
#------------------------------------------------------------------------------

# Parse command line options:
get-command-options() {
  [ $# -eq 0 ] && set -- --help

  [ -n "$GIT_SUBREPO_DEBUG" ] && set -x
  [ -n "$GIT_SUBREPO_QUIET" ] && quiet_output=true
  [ -n "$GIT_SUBREPO_VERBOSE" ] && verbose_output=true

  eval "$(
    echo "$GETOPT_SPEC" |
      git rev-parse --parseopt -- "$@" ||
    echo exit $?
  )"

  while [ $# -gt 0 ]; do
    local option="$1"; shift
    case "$option" in
      -q) quiet_output=true ;;
      -v) verbose_output=true ;;
      -x) set -x ;;
      -b) subrepo_branch="$1"; shift ;;
      --version)
        echo $VERSION
        exit ;;
      --) break ;;
      *) error "unexpected option: $option" ;;
    esac
  done

  command="$1"; shift
  command_arguments=("$@")
}

command-setup() {
  # Sanity check subdir:
  [ -n "$subdir" ] ||
    die "subdir not set"
  [[ "$subdir" =~ ^/ ]] &&
    error "subdir '$dir' should not be absolute path"
  checkout_branch="subrepo/$subdir"

  # Read/parse the .gitrepo file (unless clone; doesn't exist yet)
  gitrepo="$subdir/.gitrepo"
  if [ "$command" == "clone" ]; then
    assert-subdir-empty
    fetch-subrepo
  else
    read-gitrepo-file
    fetch-subrepo
  fi

  # Get the original branch and commit:
  local original_head="$(cat .git/HEAD)"
  [[ "$original_head" =~ ^ref:\ refs/heads/ ]] ||
    error "you need to be on a branch"
  original_branch="${original_head#ref: refs/heads/}"
  original_head_commit=$(git rev-parse HEAD)
}

fetch-subrepo() {
  # Fetch all the git objects from the subrepo/branch:
  git fetch --quiet "$subrepo_remote" "$subrepo_branch" \
    &> /dev/null \
    || error "command failed: git fetch $subrepo_remote $subrepo_branch"

  # Get the subrepo HEAD commit:
  upstream_head="$(git rev-parse FETCH_HEAD)"
}

# Determine the correct subdir path to use:
guess-subdir() {
  local dir="$1"
  dir="${dir%/}"
  dir="${dir%.git}"
  dir="${dir%/}"
  dir="${dir##*/}"
  [[ "$dir" =~ ^[-a-zA-Z0-9]+$ ]] ||
    error "can't determine subdir from '$subrepo_remote'"
  echo "$dir"
}

# Set subdir and gitrepo vars:
read-gitrepo-file() {
  gitrepo="$subdir/.gitrepo"

  if [ ! -f "$gitrepo" ]; then
    error "'$subdir' is not a subrepo"
  fi

  # Read .gitrepo values:
  subrepo_remote="$(git config --file="$gitrepo" subrepo.remote)"
  [ -z "$subrepo_branch" ] &&
    subrepo_branch="$(git config --file="$gitrepo" subrepo.branch)"
  subrepo_commit_old="$(git config --file="$gitrepo" subrepo.commit)"
  subrepo_former="$(git config --file="$gitrepo" subrepo.former)"
}

# Update the subdir/.gitrepo state file:
update-gitrepo-file() {
  local short_commit=$(git rev-parse --short "$update_commit")

  if [ "$command" == "clone" ]; then
    cat <<... > $gitrepo
; DO NOT EDIT (unless you know what you are doing)
;
; This subdirectory is a git "subrepo", and this file is maintained by the
; git-subrepo command. See https://github.com/ingydotnet/git-subrepo#readme
;
...
  fi

  git config --file="$gitrepo" subrepo.remote "$subrepo_remote"
  git config --file="$gitrepo" subrepo.branch "$subrepo_branch"
  git config --file="$gitrepo" subrepo.commit "$upstream_head"
  git config --file="$gitrepo" subrepo.former "$update_commit"
  git config --file="$gitrepo" subrepo.cmdver "$VERSION"
  git add "$gitrepo"
  git commit \
    --quiet \
    --amend \
    --message="Merge subrepo commit '$short_commit'"
}

# TODO Make this smarter:
update-remotes-branches() {
  git remote rm "subrepo/$subdir" &> /dev/null || true
  git remote add "subrepo/$subdir" "$subrepo_remote"
  git branch --force "subrepo/remote/$subdir" "${upstream_head:-$subrepo_commit_old}"
}

# Commit msg for an action commit:
action-message() {
  local commit=$(git rev-parse --short $upstream_head)
  cat <<...
subrepo $command: $subrepo_remote ($subrepo_branch) -> $subdir/

  subdir: $subdir
  remote: $subrepo_remote
  branch: $subrepo_branch
  commit: $commit

git-subrepo version: $VERSION
...
}

# Check that system is ok for this command:
assert-environment-ok() {
  type git &> /dev/null ||
    error "can't find your 'git' command in '$PATH'"
  local version="$(git --version)"
  if [[ "$version" < "git version 1.7" ]]; then
    error "requires git version 1.7 or higher; you have '$version'"
  fi
}

# Make sure git repo is ready:
assert-repo-is-ready() {
  # In a work-tree:
  [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" == true ] ||
    error "can't 'subrepo $command' outside a working tree."

  # HEAD exists:
  git rev-parse --verify HEAD >/dev/null || die

  # Repo is in a clean state:
  git update-index -q --ignore-submodules --refresh
  git diff-files --quiet --ignore-submodules ||
    error "can't $command subrepo. Unstaged changes."
  git diff-index --quiet --ignore-submodules HEAD ||
    error "can't $command subrepo. Working tree has changes."
  git diff-index --quiet --cached --ignore-submodules HEAD ||
    error "can't $command subrepo. Index has changes."

  # For now, only support actions from top of repo:
  [ "$(git rev-parse --git-dir)" == '.git' ] ||
    error "need to run subrepo command from top level directory of the repo."

  :
}

# If subdir exists, make sure it is empty:
assert-subdir-empty() {
  if [ -e "$subdir" ] && [ -n "$(ls -A $subdir)" ]; then
    error "subdir '$subdir' exists and is not empty"
  fi
}

get-all-subrepos() {
  local paths=($(
    find . -name '.gitrepo' | grep '/.gitrepo$' | sed 's/.gitrepo$//' | sort
  ))
  all_subrepos=()
  local path
  for path in "${paths[@]}"; do
    add-subrepo "$path"
  done
}

add-subrepo() {
  for path in "${all_subrepos[@]}"; do
    [[ "$1" =~ ^$path ]] && return
  done
  all_subrepos+=("$1")
}

# Smart output:
say() {
  $quiet_output && return
  echo "$@"
}

OK() {
  [ $OK ]
}

# Nicely report common error messages:
error() {
  local msg=
  printf -v msg "Error: %s\n" "$1"
  die "$msg"
}

[ "$BASH_SOURCE" == "$0" ] && main "$@"

true
