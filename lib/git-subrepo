#!/usr/bin/env bash
#
# Copyright 2013 - Ingy döt Net <ingy@ingy.net>
#

# Exit on any errors:
set -e

# Import Bash+ helper functions:
BASHLIB="${BASH_SOURCE%/*}/git-subrepo.d"
PATH="$BASHLIB:$PATH" source bash+.bash
bash+:import :std can

VERSION=0.0.1

# `git rev-parse` turns this into a getopt parser and a command usage:
GETOPT_SPEC="\
git subrepo <command> <options> <arguments>

Commands:
  clone, push, pull, status, help

See 'git help subrepo' for complete documentation and usage of each command.

Options:
--
h           Show the command summary
help        Show the complete documentation

b,branch=   Which branch/commit/refspec (default to master)

q,quiet     Show minimal output
v,verbose   Show verbose output
X,debug     Turn on -x Bash debugging
"

#------------------------------------------------------------------------------
# Top level function:
#------------------------------------------------------------------------------
main() {
  # Define globals:
  local command= command_arguments=() subrepo_branch=master
  local quiet_output=false verbose_output=false

  # Check environment and parse CLI options:
  setup
  get-opts "$@"

  # Run the command:
  can "command:$command" ||
    error "unknown 'git subrepo' command: '$command'\n"
  "command:$command" "${command_arguments[@]}"
}

#------------------------------------------------------------------------------
# API command functions:
#------------------------------------------------------------------------------
command:help() {
  exec git help subrepo
}

# `git subrepo pull …` command:
command:clone() {
  # Define local variables:
  local subrepo_url="${1:?"subrepo url required"}"
  local subdir="$(get-subdir "$2")"
  local gitrepo="$subdir/.gitrepo"
  local head_commit subrepo_commit tree_commit update_commit merge_commit

  # Setup:
  assert-empty $subdir
  assert-ready

  # Get the current HEAD commit:
  head_commit=$(git rev-parse HEAD)

  # Fetch all the git objects from the subrepo/branch:
  git fetch --quiet "$subrepo_url" "$subrepo_branch" 2> /dev/null ||
    error "command failed: git fetch $subrepo_url $subrepo_branch"

  # Get the subrepo HEAD commit:
  subrepo_commit="$(git rev-parse FETCH_HEAD)"

  # Read the subrepo into the index (under subdir):
  git read-tree --prefix="$subdir" $subrepo_commit

  # Checkout the subrepo as a new subdir:
  git checkout -- "$subdir"

  # Make a tree object from the index:
  tree_commit=$(git write-tree)

  # Create a commit object from the tree:
  update_commit="$(
    action-message cloned | git commit-tree \
      "$(git log --max-count=1 --format=%T $subrepo_commit)" \
      -p $head_commit
  )"

  # Create a merge commit:
  merge_commit="$(
    echo "Merge commit '$(git rev-parse --short "$update_commit")'" |
    git commit-tree $tree_commit \
      -p $head_commit \
      -p $update_commit
  )"

  # Set HEAD:
  git reset "$merge_commit"

  # Add/amend the subdir/.gitrepo file:
  update-gitrepo "$update_commit"

  # Successful command output:
  say "git subrepo '$subrepo_url' cloned into '$subdir'"
}

# `git subrepo pull …` command:
command:pull() {
  # Define local variables:
  local subdir gitrepo subrepo_url subrepo_branch subrepo_prev
  local subrepo_commit subrepo_old_commit update_commit

  # Setup:
  set-subdir "$1"
  assert-ready
  assert-clean
  read-gitrepo

  # Fetch the current subrepo objects:
  git fetch --quiet "$subrepo_url" "$subrepo_branch" 2> /dev/null ||
    die "failure: git fetch $subrepo_url $subrepo_branch"

  # Get the current subrepo HEAD commit:
  subrepo_commit=$(git rev-parse FETCH_HEAD)

  # Check if we already are up to date:
  if [ "$subrepo_commit" == "$subrepo_old_commit" ]; then
    say "subrepo '$subdir' is up to date"
    return
  fi

  # Create the update commit:
  update_commit="$(
    action-message pulled | git commit-tree \
      "$(git log --max-count=1 --format=%T "$subrepo_commit")" \
      -p "$subrepo_prev"
  )"

  # Merge the update with the subtree strategy:
  git merge -s recursive -X subtree="$subdir" "$update_commit" > /dev/null

  # Add/amend the subdir/.gitrepo file:
  update-gitrepo "$update_commit"

  # Successful command output:
  say "git subrepo '$subdir' pulled from '$subrepo_url' ($subrepo_branch)"
}

# `git subrepo push …` command:
command:push() {
  local subdir gitrepo subrepo_url subrepo_branch subrepo_prev
  local subrepo_commit update_commit

  # Setup:
  set-subdir "$1"
  assert-ready
  assert-clean
  read-gitrepo

  # TODO: git filter-branch
  die $subrepo_old_commit
}

# `git subrepo status …` command:
command:status() {
  local subdir gitrepo
}


#------------------------------------------------------------------------------
# Support functions:
#------------------------------------------------------------------------------

# Check git sanity:
setup() {
  type git &> /dev/null ||
    error "can't find your 'git' command in '$PATH'"
  local version="$(git --version)"
  if [[ "$version" < "git version 1.7" ]]; then
    error "requires git version 1.7 or higher; you have '$version'"
  fi
}

# Parse command line options:
get-opts() {
  [ $# -eq 0 ] && set -- --help

  [ -n "$GIT_SUBREPO_DEBUG" ] && set -x
  [ -n "$GIT_SUBREPO_QUIET" ] && quiet_output=true
  [ -n "$GIT_SUBREPO_VERBOSE" ] && verbose_output=true

  eval "$(
    echo "$GETOPT_SPEC" |
      git rev-parse --parseopt -- "$@" ||
    echo exit $?
  )"

  while [ $# -gt 0 ]; do
    local option="$1"; shift
    case "$option" in
      -q) quiet_output=true ;;
      -v) verbose_output=true ;;
      -X) set -x ;;
      -b) subrepo_branch="$1"; shift ;;
      --) break ;;
      *) error "unexpected option: $option" ;;
    esac
  done

  command="$1"; shift
  command_arguments=("$@")
}

# Set subdir and gitrepo vars:
set-subdir() {
  subdir="$(get-subdir "$1")"
  gitrepo="$subdir/.gitrepo"

  if [ ! -f "$gitrepo" ]; then
    error "'$subdir' is not a subrepo"
  fi
}

# Determine the correct subdir path to use:
get-subdir() {
  local dir="$1"
  if [ -z "$dir" ]; then
    dir="${subrepo_url##*/}"
    dir="${dir%.git}"
    [[ "$dir" =~ [a-zA-Z] ]] ||
      error "can't determine subdir from '$subrepo_url'"
  fi
  [[ "$dir" =~ ^/ ]] &&
    error "subdir '$dir' should not be absolute path"
  dir="${dir%%/}"
  echo "$dir"
}

# Make sure git repo is ready:
assert-ready() {
  if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" != true ]; then
    error "can't 'subrepo $command' outside a working tree."
  fi
}

# If subdir exists, make sure it is empty:
assert-empty() {
  subdir="$1"
  if [ -e "$subdir" ] && [ -n "$(ls -A $subdir)" ]; then
    error "subdir '$subdir' exists and is not empty"
  fi
}

# Make sure repo is in a clean state:
assert-clean() {
  git rev-parse --verify HEAD >/dev/null || die
  git update-index -q --ignore-submodules --refresh
  git diff-files --quiet --ignore-submodules ||
    error "can't $action subrepo. Unstaged changes."
  git diff-index --quiet --ignore-submodules HEAD ||
    error "can't $action subrepo. Working tree has changes."
  git diff-index --quiet --cached --ignore-submodules HEAD ||
    error "can't $action subrepo. Index has changes."
  :
}

read-gitrepo() {
  subrepo_url="$(git config --file="$gitrepo" subrepo.url)"
  subrepo_branch="$(git config --file="$gitrepo" subrepo.branch)"
  subrepo_old_commit="$(git config --file="$gitrepo" subrepo.commit)"
  subrepo_prev="$(git config --file="$gitrepo" subrepo.prev)"
}

# Commit msg for an action commit:
action-message() {
  action="$1"
  cat <<...
subrepo $action into '$subdir/'

subrepo url:    $subrepo_url
subrepo branch: $subrepo_branch
subrepo commit: $subrepo_commit
...
}

# Update the subdir/.gitrepo state file:
update-gitrepo() {
  local change_commit="$1"
  local short_commit=$(git rev-parse --short "$change_commit")

  git config --file="$gitrepo" subrepo.url "$subrepo_url"
  git config --file="$gitrepo" subrepo.branch "$subrepo_branch"
  git config --file="$gitrepo" subrepo.commit "$subrepo_commit"
  git config --file="$gitrepo" subrepo.prev "$change_commit"
  git add "$gitrepo"
  git commit \
    --quiet \
    --amend \
    --message="Merge subrepo commit '$short_commit'"
}

# Smart output:
say() {
  $quiet_output && return
  echo "$@"
}

# Nicely report common error messages:
error() {
  local msg=
  printf -v msg "Error: %s\n" "$1"
  die "$msg"
}

[ "$BASH_SOURCE" == "$0" ] && main "$@"

true
